/* tslint:disable */
/* eslint-disable */
/**
 * Bitly API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BadRequest,
  BitlinkScans,
  BitlinkScansSummary,
  CityScanMetrics,
  Forbidden,
  Gone,
  InternalError,
  MonthlyLimitExceeded,
  NotFound,
  PublicCreateQRCodeRequest,
  PublicDeleteQRCodeResponse,
  PublicQRCodeImageResponse,
  PublicUpdateQRCodeRequest,
  QRCodeDetails,
  QRCodeMinimal,
  QRCodesMinimal,
  ScanMetrics,
  TemporarilyUnavailable,
  TimeUnit,
  UpgradeRequired,
} from '../models/index';
import {
    BadRequestFromJSON,
    BadRequestToJSON,
    BitlinkScansFromJSON,
    BitlinkScansToJSON,
    BitlinkScansSummaryFromJSON,
    BitlinkScansSummaryToJSON,
    CityScanMetricsFromJSON,
    CityScanMetricsToJSON,
    ForbiddenFromJSON,
    ForbiddenToJSON,
    GoneFromJSON,
    GoneToJSON,
    InternalErrorFromJSON,
    InternalErrorToJSON,
    MonthlyLimitExceededFromJSON,
    MonthlyLimitExceededToJSON,
    NotFoundFromJSON,
    NotFoundToJSON,
    PublicCreateQRCodeRequestFromJSON,
    PublicCreateQRCodeRequestToJSON,
    PublicDeleteQRCodeResponseFromJSON,
    PublicDeleteQRCodeResponseToJSON,
    PublicQRCodeImageResponseFromJSON,
    PublicQRCodeImageResponseToJSON,
    PublicUpdateQRCodeRequestFromJSON,
    PublicUpdateQRCodeRequestToJSON,
    QRCodeDetailsFromJSON,
    QRCodeDetailsToJSON,
    QRCodeMinimalFromJSON,
    QRCodeMinimalToJSON,
    QRCodesMinimalFromJSON,
    QRCodesMinimalToJSON,
    ScanMetricsFromJSON,
    ScanMetricsToJSON,
    TemporarilyUnavailableFromJSON,
    TemporarilyUnavailableToJSON,
    TimeUnitFromJSON,
    TimeUnitToJSON,
    UpgradeRequiredFromJSON,
    UpgradeRequiredToJSON,
} from '../models/index';

export interface CreateQRCodePublicRequest {
    public_create_qr_code_request: PublicCreateQRCodeRequest;
}

export interface DeleteQRCodeRequest {
    qrcode_id: string;
}

export interface GetQRCodeByIdPublicRequest {
    qrcode_id: string;
}

export interface GetQRCodeImagePublicRequest {
    qrcode_id: string;
    accept?: string;
    format?: GetQRCodeImagePublicFormatEnum;
}

export interface GetScanMetricsForQRCodeRequest {
    qrcode_id: string;
    unit: TimeUnit;
    units: number;
    unit_reference?: string;
}

export interface GetScanMetricsForQRCodeByBrowserRequest {
    qrcode_id: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetScanMetricsForQRCodeByCitiesRequest {
    qrcode_id: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetScanMetricsForQRCodeByCountriesRequest {
    qrcode_id: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetScanMetricsForQRCodeByDevicesOSRequest {
    qrcode_id: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetScanMetricsSummaryForQRCodeRequest {
    qrcode_id: string;
    unit: TimeUnit;
    units: number;
    unit_reference?: string;
}

export interface ListQRMinimalRequest {
    group_guid: string;
    has_render_customizations?: ListQRMinimalHasRenderCustomizationsEnum;
    size?: number;
    search_after?: string;
    query?: string;
    hostname_path_query?: string;
    created_before?: number;
    created_after?: number;
    archived?: ListQRMinimalArchivedEnum;
    creating_login?: Array<string>;
    qrc_type?: Array<ListQRMinimalQrcTypeEnum>;
    is_gs1?: ListQRMinimalIsGs1Enum;
}

export interface UpdateQRCodePublicRequest {
    qrcode_id: string;
    public_update_qr_code_request: PublicUpdateQRCodeRequest;
}

/**
 * 
 */
export class QRCodesApi extends runtime.BaseAPI {

    /**
     * Create a new QR Code and return its metadata
     * Create a QR Code
     */
    async createQRCodePublicRaw(requestParameters: CreateQRCodePublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QRCodeMinimal>> {
        if (requestParameters['public_create_qr_code_request'] == null) {
            throw new runtime.RequiredError(
                'public_create_qr_code_request',
                'Required parameter "public_create_qr_code_request" was null or undefined when calling createQRCodePublic().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PublicCreateQRCodeRequestToJSON(requestParameters['public_create_qr_code_request']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QRCodeMinimalFromJSON(jsonValue));
    }

    /**
     * Create a new QR Code and return its metadata
     * Create a QR Code
     */
    async createQRCodePublic(requestParameters: CreateQRCodePublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QRCodeMinimal> {
        const response = await this.createQRCodePublicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a QR Code that has not been redirected and is not for a custom link. Also deletes the associated link (if applicable).
     * Delete a QR Code
     */
    async deleteQRCodeRaw(requestParameters: DeleteQRCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicDeleteQRCodeResponse>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling deleteQRCode().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicDeleteQRCodeResponseFromJSON(jsonValue));
    }

    /**
     * Delete a QR Code that has not been redirected and is not for a custom link. Also deletes the associated link (if applicable).
     * Delete a QR Code
     */
    async deleteQRCode(requestParameters: DeleteQRCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicDeleteQRCodeResponse> {
        const response = await this.deleteQRCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the QR code with a matching id.
     * Retrieve a QR Code
     */
    async getQRCodeByIdPublicRaw(requestParameters: GetQRCodeByIdPublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QRCodeDetails>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling getQRCodeByIdPublic().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QRCodeDetailsFromJSON(jsonValue));
    }

    /**
     * Gets the QR code with a matching id.
     * Retrieve a QR Code
     */
    async getQRCodeByIdPublic(requestParameters: GetQRCodeByIdPublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QRCodeDetails> {
        const response = await this.getQRCodeByIdPublicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the image of a given QR Code. The Accept header controls how this is returned (options are \"application/json\", \"image/svg+xml\", and \"image/png\"). If the Accept header is \"application/json\" the format query parameter will determine the image format inside of the json (which will be base64 encoded and prefixed with its mime type as would be suitable for a HTML image src tag). To Return the QR Code image itself, set the Accept header to \"image/svg+xml\" or \"image/png\", or remove the Accept header and set the format query parameter to “svg” or “png” (if no format is specified the default will be “svg”). 
     * Retrieve a QR Code image
     */
    async getQRCodeImagePublicRaw(requestParameters: GetQRCodeImagePublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicQRCodeImageResponse>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling getQRCodeImagePublic().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['accept'] != null) {
            headerParameters['Accept'] = String(requestParameters['accept']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}/image`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicQRCodeImageResponseFromJSON(jsonValue));
    }

    /**
     * Get the image of a given QR Code. The Accept header controls how this is returned (options are \"application/json\", \"image/svg+xml\", and \"image/png\"). If the Accept header is \"application/json\" the format query parameter will determine the image format inside of the json (which will be base64 encoded and prefixed with its mime type as would be suitable for a HTML image src tag). To Return the QR Code image itself, set the Accept header to \"image/svg+xml\" or \"image/png\", or remove the Accept header and set the format query parameter to “svg” or “png” (if no format is specified the default will be “svg”). 
     * Retrieve a QR Code image
     */
    async getQRCodeImagePublic(requestParameters: GetQRCodeImagePublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicQRCodeImageResponse> {
        const response = await this.getQRCodeImagePublicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an array of scan counts for the specified QR code. The array is comprised of scan counts for each time window, where the window is based on the provided unit.
     * Get Scans for a QR Code
     */
    async getScanMetricsForQRCodeRaw(requestParameters: GetScanMetricsForQRCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BitlinkScans>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling getScanMetricsForQRCode().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getScanMetricsForQRCode().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getScanMetricsForQRCode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}/scans`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BitlinkScansFromJSON(jsonValue));
    }

    /**
     * Returns an array of scan counts for the specified QR code. The array is comprised of scan counts for each time window, where the window is based on the provided unit.
     * Get Scans for a QR Code
     */
    async getScanMetricsForQRCode(requestParameters: GetScanMetricsForQRCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BitlinkScans> {
        const response = await this.getScanMetricsForQRCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the browsers generating scan traffic to the specified QR Code.
     * Get Scans for a QR Code by Browser
     */
    async getScanMetricsForQRCodeByBrowserRaw(requestParameters: GetScanMetricsForQRCodeByBrowserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScanMetrics>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling getScanMetricsForQRCodeByBrowser().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getScanMetricsForQRCodeByBrowser().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getScanMetricsForQRCodeByBrowser().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}/scans/browsers`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScanMetricsFromJSON(jsonValue));
    }

    /**
     * Returns the browsers generating scan traffic to the specified QR Code.
     * Get Scans for a QR Code by Browser
     */
    async getScanMetricsForQRCodeByBrowser(requestParameters: GetScanMetricsForQRCodeByBrowserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScanMetrics> {
        const response = await this.getScanMetricsForQRCodeByBrowserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the city origins of scan traffic for the specified QR Code.
     * Get Metrics for a QR Code by City
     */
    async getScanMetricsForQRCodeByCitiesRaw(requestParameters: GetScanMetricsForQRCodeByCitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CityScanMetrics>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling getScanMetricsForQRCodeByCities().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getScanMetricsForQRCodeByCities().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getScanMetricsForQRCodeByCities().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}/scans/cities`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CityScanMetricsFromJSON(jsonValue));
    }

    /**
     * Returns the city origins of scan traffic for the specified QR Code.
     * Get Metrics for a QR Code by City
     */
    async getScanMetricsForQRCodeByCities(requestParameters: GetScanMetricsForQRCodeByCitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CityScanMetrics> {
        const response = await this.getScanMetricsForQRCodeByCitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the country origins of scan traffic for the specified QR Code.
     * Get Scans for a QR Code by Country
     */
    async getScanMetricsForQRCodeByCountriesRaw(requestParameters: GetScanMetricsForQRCodeByCountriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScanMetrics>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling getScanMetricsForQRCodeByCountries().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getScanMetricsForQRCodeByCountries().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getScanMetricsForQRCodeByCountries().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}/scans/countries`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScanMetricsFromJSON(jsonValue));
    }

    /**
     * Returns the country origins of scan traffic for the specified QR Code.
     * Get Scans for a QR Code by Country
     */
    async getScanMetricsForQRCodeByCountries(requestParameters: GetScanMetricsForQRCodeByCountriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScanMetrics> {
        const response = await this.getScanMetricsForQRCodeByCountriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the device os generating scan traffic for the specified QR Code.
     * Get Scans for a QR Code by Device OS
     */
    async getScanMetricsForQRCodeByDevicesOSRaw(requestParameters: GetScanMetricsForQRCodeByDevicesOSRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ScanMetrics>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling getScanMetricsForQRCodeByDevicesOS().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getScanMetricsForQRCodeByDevicesOS().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getScanMetricsForQRCodeByDevicesOS().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}/scans/device_os`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ScanMetricsFromJSON(jsonValue));
    }

    /**
     * Returns the device os generating scan traffic for the specified QR Code.
     * Get Scans for a QR Code by Device OS
     */
    async getScanMetricsForQRCodeByDevicesOS(requestParameters: GetScanMetricsForQRCodeByDevicesOSRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ScanMetrics> {
        const response = await this.getScanMetricsForQRCodeByDevicesOSRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the scan counts for a QR Code rolled up into a single field for a specified time window, where the window is based on the provided unit.
     * Get Scans Summary for a QR Code
     */
    async getScanMetricsSummaryForQRCodeRaw(requestParameters: GetScanMetricsSummaryForQRCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BitlinkScansSummary>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling getScanMetricsSummaryForQRCode().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getScanMetricsSummaryForQRCode().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getScanMetricsSummaryForQRCode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}/scans/summary`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BitlinkScansSummaryFromJSON(jsonValue));
    }

    /**
     * Returns the scan counts for a QR Code rolled up into a single field for a specified time window, where the window is based on the provided unit.
     * Get Scans Summary for a QR Code
     */
    async getScanMetricsSummaryForQRCode(requestParameters: GetScanMetricsSummaryForQRCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BitlinkScansSummary> {
        const response = await this.getScanMetricsSummaryForQRCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of QR codes matching the filter settings. Values are in reverse chronological order. The pagination occurs by calling the next link in the pagination response object. 
     * Retrieve QR Codes by Group
     */
    async listQRMinimalRaw(requestParameters: ListQRMinimalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QRCodesMinimal>> {
        if (requestParameters['group_guid'] == null) {
            throw new runtime.RequiredError(
                'group_guid',
                'Required parameter "group_guid" was null or undefined when calling listQRMinimal().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['has_render_customizations'] != null) {
            queryParameters['has_render_customizations'] = requestParameters['has_render_customizations'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['search_after'] != null) {
            queryParameters['search_after'] = requestParameters['search_after'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['hostname_path_query'] != null) {
            queryParameters['hostname_path_query'] = requestParameters['hostname_path_query'];
        }

        if (requestParameters['created_before'] != null) {
            queryParameters['created_before'] = requestParameters['created_before'];
        }

        if (requestParameters['created_after'] != null) {
            queryParameters['created_after'] = requestParameters['created_after'];
        }

        if (requestParameters['archived'] != null) {
            queryParameters['archived'] = requestParameters['archived'];
        }

        if (requestParameters['creating_login'] != null) {
            queryParameters['creating_login'] = requestParameters['creating_login'];
        }

        if (requestParameters['qrc_type'] != null) {
            queryParameters['qrc_type'] = requestParameters['qrc_type'];
        }

        if (requestParameters['is_gs1'] != null) {
            queryParameters['is_gs1'] = requestParameters['is_gs1'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/groups/{group_guid}/qr-codes`;
        urlPath = urlPath.replace(`{${"group_guid"}}`, encodeURIComponent(String(requestParameters['group_guid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QRCodesMinimalFromJSON(jsonValue));
    }

    /**
     * Retrieves a list of QR codes matching the filter settings. Values are in reverse chronological order. The pagination occurs by calling the next link in the pagination response object. 
     * Retrieve QR Codes by Group
     */
    async listQRMinimal(requestParameters: ListQRMinimalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QRCodesMinimal> {
        const response = await this.listQRMinimalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the QR code with a matching id and returns it.
     * Update a QR Code
     */
    async updateQRCodePublicRaw(requestParameters: UpdateQRCodePublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QRCodeMinimal>> {
        if (requestParameters['qrcode_id'] == null) {
            throw new runtime.RequiredError(
                'qrcode_id',
                'Required parameter "qrcode_id" was null or undefined when calling updateQRCodePublic().'
            );
        }

        if (requestParameters['public_update_qr_code_request'] == null) {
            throw new runtime.RequiredError(
                'public_update_qr_code_request',
                'Required parameter "public_update_qr_code_request" was null or undefined when calling updateQRCodePublic().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/qr-codes/{qrcode_id}`;
        urlPath = urlPath.replace(`{${"qrcode_id"}}`, encodeURIComponent(String(requestParameters['qrcode_id'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PublicUpdateQRCodeRequestToJSON(requestParameters['public_update_qr_code_request']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QRCodeMinimalFromJSON(jsonValue));
    }

    /**
     * Updates the QR code with a matching id and returns it.
     * Update a QR Code
     */
    async updateQRCodePublic(requestParameters: UpdateQRCodePublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QRCodeMinimal> {
        const response = await this.updateQRCodePublicRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum GetQRCodeImagePublicFormatEnum {
    svg = 'svg',
    png = 'png'
}
/**
  * @export
  * @enum {string}
  */
export enum ListQRMinimalHasRenderCustomizationsEnum {
    on = 'on',
    off = 'off',
    both = 'both'
}
/**
  * @export
  * @enum {string}
  */
export enum ListQRMinimalArchivedEnum {
    on = 'on',
    off = 'off',
    both = 'both'
}
/**
  * @export
  * @enum {string}
  */
export enum ListQRMinimalQrcTypeEnum {
    bitlink = 'bitlink',
    long_url = 'long_url'
}
/**
  * @export
  * @enum {string}
  */
export enum ListQRMinimalIsGs1Enum {
    on = 'on',
    off = 'off',
    both = 'both'
}
