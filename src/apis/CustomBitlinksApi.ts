/* tslint:disable */
/* eslint-disable */
/**
 * Bitly API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddCustomBitlink,
  BadRequest,
  ClickMetrics,
  Clicks,
  CustomBitlink,
  Forbidden,
  Gone,
  InternalError,
  MonthlyLimitExceeded,
  NotFound,
  TemporarilyUnavailable,
  TimeUnit,
  UnprocessableEntity,
  UpdateCustomBitlink,
  UpgradeRequired,
} from '../models/index';
import {
    AddCustomBitlinkFromJSON,
    AddCustomBitlinkToJSON,
    BadRequestFromJSON,
    BadRequestToJSON,
    ClickMetricsFromJSON,
    ClickMetricsToJSON,
    ClicksFromJSON,
    ClicksToJSON,
    CustomBitlinkFromJSON,
    CustomBitlinkToJSON,
    ForbiddenFromJSON,
    ForbiddenToJSON,
    GoneFromJSON,
    GoneToJSON,
    InternalErrorFromJSON,
    InternalErrorToJSON,
    MonthlyLimitExceededFromJSON,
    MonthlyLimitExceededToJSON,
    NotFoundFromJSON,
    NotFoundToJSON,
    TemporarilyUnavailableFromJSON,
    TemporarilyUnavailableToJSON,
    TimeUnitFromJSON,
    TimeUnitToJSON,
    UnprocessableEntityFromJSON,
    UnprocessableEntityToJSON,
    UpdateCustomBitlinkFromJSON,
    UpdateCustomBitlinkToJSON,
    UpgradeRequiredFromJSON,
    UpgradeRequiredToJSON,
} from '../models/index';

export interface AddCustomBitlinkRequest {
    add_custom_bitlink: AddCustomBitlink;
}

export interface GetClicksForCustomBitlinkRequest {
    custom_bitlink: string;
    unit: TimeUnit;
    units: number;
    unit_reference?: string;
}

export interface GetCustomBitlinkRequest {
    custom_bitlink: string;
}

export interface GetCustomBitlinkMetricsByDestinationRequest {
    custom_bitlink: string;
    unit: TimeUnit;
    units: number;
    unit_reference?: string;
}

export interface UpdateCustomBitlinkRequest {
    custom_bitlink: string;
    update_custom_bitlink: UpdateCustomBitlink;
}

/**
 * 
 */
export class CustomBitlinksApi extends runtime.BaseAPI {

    /**
     * Add a keyword (or \"custom back-half\") to a Bitlink with a Custom Domain (domains must match). This endpoint can also be used for initial redirects to a link.
     * Add Custom Bitlink
     */
    async addCustomBitlinkRaw(requestParameters: AddCustomBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomBitlink>> {
        if (requestParameters['add_custom_bitlink'] == null) {
            throw new runtime.RequiredError(
                'add_custom_bitlink',
                'Required parameter "add_custom_bitlink" was null or undefined when calling addCustomBitlink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/custom_bitlinks`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddCustomBitlinkToJSON(requestParameters['add_custom_bitlink']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomBitlinkFromJSON(jsonValue));
    }

    /**
     * Add a keyword (or \"custom back-half\") to a Bitlink with a Custom Domain (domains must match). This endpoint can also be used for initial redirects to a link.
     * Add Custom Bitlink
     */
    async addCustomBitlink(requestParameters: AddCustomBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomBitlink> {
        const response = await this.addCustomBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the click counts for the specified link. This returns an array with clicks based on a date.
     * Get Clicks for a Custom Bitlink\'s Entire History
     */
    async getClicksForCustomBitlinkRaw(requestParameters: GetClicksForCustomBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Clicks>> {
        if (requestParameters['custom_bitlink'] == null) {
            throw new runtime.RequiredError(
                'custom_bitlink',
                'Required parameter "custom_bitlink" was null or undefined when calling getClicksForCustomBitlink().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getClicksForCustomBitlink().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getClicksForCustomBitlink().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/custom_bitlinks/{custom_bitlink}/clicks`;
        urlPath = urlPath.replace(`{${"custom_bitlink"}}`, encodeURIComponent(String(requestParameters['custom_bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClicksFromJSON(jsonValue));
    }

    /**
     * Returns the click counts for the specified link. This returns an array with clicks based on a date.
     * Get Clicks for a Custom Bitlink\'s Entire History
     */
    async getClicksForCustomBitlink(requestParameters: GetClicksForCustomBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Clicks> {
        const response = await this.getClicksForCustomBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the details and history of the specified link.
     * Retrieve Custom Bitlink
     */
    async getCustomBitlinkRaw(requestParameters: GetCustomBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomBitlink>> {
        if (requestParameters['custom_bitlink'] == null) {
            throw new runtime.RequiredError(
                'custom_bitlink',
                'Required parameter "custom_bitlink" was null or undefined when calling getCustomBitlink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/custom_bitlinks/{custom_bitlink}`;
        urlPath = urlPath.replace(`{${"custom_bitlink"}}`, encodeURIComponent(String(requestParameters['custom_bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomBitlinkFromJSON(jsonValue));
    }

    /**
     * Returns the details and history of the specified link.
     * Retrieve Custom Bitlink
     */
    async getCustomBitlink(requestParameters: GetCustomBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomBitlink> {
        const response = await this.getCustomBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns click metrics for the specified link by its historical destinations.
     * Get Metrics for a Custom Bitlink by Destination
     */
    async getCustomBitlinkMetricsByDestinationRaw(requestParameters: GetCustomBitlinkMetricsByDestinationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClickMetrics>> {
        if (requestParameters['custom_bitlink'] == null) {
            throw new runtime.RequiredError(
                'custom_bitlink',
                'Required parameter "custom_bitlink" was null or undefined when calling getCustomBitlinkMetricsByDestination().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getCustomBitlinkMetricsByDestination().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getCustomBitlinkMetricsByDestination().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/custom_bitlinks/{custom_bitlink}/clicks_by_destination`;
        urlPath = urlPath.replace(`{${"custom_bitlink"}}`, encodeURIComponent(String(requestParameters['custom_bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClickMetricsFromJSON(jsonValue));
    }

    /**
     * Returns click metrics for the specified link by its historical destinations.
     * Get Metrics for a Custom Bitlink by Destination
     */
    async getCustomBitlinkMetricsByDestination(requestParameters: GetCustomBitlinkMetricsByDestinationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClickMetrics> {
        const response = await this.getCustomBitlinkMetricsByDestinationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move a keyword (or custom back-half) to a different Bitlink (domains must match).
     * Update Custom Bitlink
     */
    async updateCustomBitlinkRaw(requestParameters: UpdateCustomBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomBitlink>> {
        if (requestParameters['custom_bitlink'] == null) {
            throw new runtime.RequiredError(
                'custom_bitlink',
                'Required parameter "custom_bitlink" was null or undefined when calling updateCustomBitlink().'
            );
        }

        if (requestParameters['update_custom_bitlink'] == null) {
            throw new runtime.RequiredError(
                'update_custom_bitlink',
                'Required parameter "update_custom_bitlink" was null or undefined when calling updateCustomBitlink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/custom_bitlinks/{custom_bitlink}`;
        urlPath = urlPath.replace(`{${"custom_bitlink"}}`, encodeURIComponent(String(requestParameters['custom_bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCustomBitlinkToJSON(requestParameters['update_custom_bitlink']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomBitlinkFromJSON(jsonValue));
    }

    /**
     * Move a keyword (or custom back-half) to a different Bitlink (domains must match).
     * Update Custom Bitlink
     */
    async updateCustomBitlink(requestParameters: UpdateCustomBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomBitlink> {
        const response = await this.updateCustomBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
