/* tslint:disable */
/* eslint-disable */
/**
 * Bitly API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BadRequest,
  BitlinkBody,
  BitlinkUpdateBody,
  Bitlinks,
  BulkUpdate,
  BulkUpdateRequest,
  CityMetrics,
  ClickMetrics,
  Clicks,
  ClicksSummary,
  Conflict,
  DeviceMetrics,
  ExpandBitlink,
  ExpandedBitlink,
  ExpectationFailed,
  Forbidden,
  FullShorten,
  Gone,
  InternalError,
  LinkDeletionResponse,
  MonthlyLimitExceeded,
  NotFound,
  ReferrersByDomains,
  Shorten,
  ShortenBitlinkBody,
  SortedLinks,
  TemporarilyUnavailable,
  TimeUnit,
  UnprocessableEntity,
  UpgradeRequired,
} from '../models/index';
import {
    BadRequestFromJSON,
    BadRequestToJSON,
    BitlinkBodyFromJSON,
    BitlinkBodyToJSON,
    BitlinkUpdateBodyFromJSON,
    BitlinkUpdateBodyToJSON,
    BitlinksFromJSON,
    BitlinksToJSON,
    BulkUpdateFromJSON,
    BulkUpdateToJSON,
    BulkUpdateRequestFromJSON,
    BulkUpdateRequestToJSON,
    CityMetricsFromJSON,
    CityMetricsToJSON,
    ClickMetricsFromJSON,
    ClickMetricsToJSON,
    ClicksFromJSON,
    ClicksToJSON,
    ClicksSummaryFromJSON,
    ClicksSummaryToJSON,
    ConflictFromJSON,
    ConflictToJSON,
    DeviceMetricsFromJSON,
    DeviceMetricsToJSON,
    ExpandBitlinkFromJSON,
    ExpandBitlinkToJSON,
    ExpandedBitlinkFromJSON,
    ExpandedBitlinkToJSON,
    ExpectationFailedFromJSON,
    ExpectationFailedToJSON,
    ForbiddenFromJSON,
    ForbiddenToJSON,
    FullShortenFromJSON,
    FullShortenToJSON,
    GoneFromJSON,
    GoneToJSON,
    InternalErrorFromJSON,
    InternalErrorToJSON,
    LinkDeletionResponseFromJSON,
    LinkDeletionResponseToJSON,
    MonthlyLimitExceededFromJSON,
    MonthlyLimitExceededToJSON,
    NotFoundFromJSON,
    NotFoundToJSON,
    ReferrersByDomainsFromJSON,
    ReferrersByDomainsToJSON,
    ShortenFromJSON,
    ShortenToJSON,
    ShortenBitlinkBodyFromJSON,
    ShortenBitlinkBodyToJSON,
    SortedLinksFromJSON,
    SortedLinksToJSON,
    TemporarilyUnavailableFromJSON,
    TemporarilyUnavailableToJSON,
    TimeUnitFromJSON,
    TimeUnitToJSON,
    UnprocessableEntityFromJSON,
    UnprocessableEntityToJSON,
    UpgradeRequiredFromJSON,
    UpgradeRequiredToJSON,
} from '../models/index';

export interface CreateBitlinkRequest {
    shorten: Shorten;
}

export interface CreateFullBitlinkRequest {
    full_shorten: FullShorten;
}

export interface DeleteBitlinkRequest {
    bitlink: string;
}

export interface ExpandBitlinkRequest {
    expand_bitlink: ExpandBitlink;
}

export interface GetBitlinkRequest {
    bitlink: string;
}

export interface GetBitlinksByGroupRequest {
    group_guid: string;
    size?: number;
    search_after?: string;
    query?: string;
    hostname_path_query?: string;
    created_before?: number;
    created_after?: number;
    archived?: GetBitlinksByGroupArchivedEnum;
    deeplinks?: GetBitlinksByGroupDeeplinksEnum;
    domain_deeplinks?: GetBitlinksByGroupDomainDeeplinksEnum;
    campaign_guid?: string;
    channel_guid?: string;
    custom_bitlink?: GetBitlinksByGroupCustomBitlinkEnum;
    has_qr_codes?: GetBitlinksByGroupHasQrCodesEnum;
    tags?: Array<string>;
    launchpad_ids?: Array<string>;
    encoding_login?: Array<string>;
}

export interface GetClicksForBitlinkRequest {
    bitlink: string;
    unit: TimeUnit;
    units: number;
    unit_reference?: string;
}

export interface GetClicksSummaryForBitlinkRequest {
    bitlink: string;
    unit: TimeUnit;
    units: number;
    unit_reference?: string;
}

export interface GetMetricsForBitlinkByCitiesRequest {
    bitlink: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetMetricsForBitlinkByCountriesRequest {
    bitlink: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetMetricsForBitlinkByDevicesRequest {
    bitlink: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetMetricsForBitlinkByReferrerNameRequest {
    bitlink: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetMetricsForBitlinkByReferrersRequest {
    bitlink: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetMetricsForBitlinkByReferrersByDomainsRequest {
    bitlink: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetMetricsForBitlinkByReferringDomainsRequest {
    bitlink: string;
    unit: TimeUnit;
    units: number;
    size?: number;
    unit_reference?: string;
}

export interface GetSortedBitlinksRequest {
    group_guid: string;
    sort: GetSortedBitlinksSortEnum;
    unit?: TimeUnit;
    units?: number;
    unit_reference?: string;
    size?: number;
}

export interface UpdateBitlinkRequest {
    bitlink: string;
    bitlink_update_body: BitlinkUpdateBody;
}

export interface UpdateBitlinksByGroupRequest {
    group_guid: string;
    bulk_update_request: BulkUpdateRequest;
}

/**
 * 
 */
export class BitlinksApi extends runtime.BaseAPI {

    /**
     * Converts a long url to a Bitlink. You may see errors returned from this endpoint - \"BRANDED_LINK_MONTHLY_LIMIT_EXCEEDED\" occurs if you have shortened more links than your account is configured for for the month, and \"DNS_CONFIGURATION_ERROR\" occurs if you are attempting to shorten links against a custom domain which doesn\'t have DNS properly configured.
     * Shorten a Link
     */
    async createBitlinkRaw(requestParameters: CreateBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShortenBitlinkBody>> {
        if (requestParameters['shorten'] == null) {
            throw new runtime.RequiredError(
                'shorten',
                'Required parameter "shorten" was null or undefined when calling createBitlink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/shorten`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShortenToJSON(requestParameters['shorten']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShortenBitlinkBodyFromJSON(jsonValue));
    }

    /**
     * Converts a long url to a Bitlink. You may see errors returned from this endpoint - \"BRANDED_LINK_MONTHLY_LIMIT_EXCEEDED\" occurs if you have shortened more links than your account is configured for for the month, and \"DNS_CONFIGURATION_ERROR\" occurs if you are attempting to shorten links against a custom domain which doesn\'t have DNS properly configured.
     * Shorten a Link
     */
    async createBitlink(requestParameters: CreateBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShortenBitlinkBody> {
        const response = await this.createBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Converts a long url to a Bitlink and sets additional parameters. You may see errors returned from this endpoint - \"BRANDED_LINK_MONTHLY_LIMIT_EXCEEDED\" occurs if you have shortened more links than your account is configured for for the month, and \"DNS_CONFIGURATION_ERROR\" occurs if you are attempting to shorten links against a custom domain which doesn\'t have DNS properly configured.
     * Create a Bitlink
     */
    async createFullBitlinkRaw(requestParameters: CreateFullBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BitlinkBody>> {
        if (requestParameters['full_shorten'] == null) {
            throw new runtime.RequiredError(
                'full_shorten',
                'Required parameter "full_shorten" was null or undefined when calling createFullBitlink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FullShortenToJSON(requestParameters['full_shorten']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BitlinkBodyFromJSON(jsonValue));
    }

    /**
     * Converts a long url to a Bitlink and sets additional parameters. You may see errors returned from this endpoint - \"BRANDED_LINK_MONTHLY_LIMIT_EXCEEDED\" occurs if you have shortened more links than your account is configured for for the month, and \"DNS_CONFIGURATION_ERROR\" occurs if you are attempting to shorten links against a custom domain which doesn\'t have DNS properly configured.
     * Create a Bitlink
     */
    async createFullBitlink(requestParameters: CreateFullBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BitlinkBody> {
        const response = await this.createFullBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an unedited hash Bitlink.
     * Delete a Bitlink
     */
    async deleteBitlinkRaw(requestParameters: DeleteBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LinkDeletionResponse>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling deleteBitlink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LinkDeletionResponseFromJSON(jsonValue));
    }

    /**
     * Delete an unedited hash Bitlink.
     * Delete a Bitlink
     */
    async deleteBitlink(requestParameters: DeleteBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LinkDeletionResponse> {
        const response = await this.deleteBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the short link and long URL for the specified link.
     * Expand a Bitlink
     */
    async expandBitlinkRaw(requestParameters: ExpandBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExpandedBitlink>> {
        if (requestParameters['expand_bitlink'] == null) {
            throw new runtime.RequiredError(
                'expand_bitlink',
                'Required parameter "expand_bitlink" was null or undefined when calling expandBitlink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/expand`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExpandBitlinkToJSON(requestParameters['expand_bitlink']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpandedBitlinkFromJSON(jsonValue));
    }

    /**
     * Returns the short link and long URL for the specified link.
     * Expand a Bitlink
     */
    async expandBitlink(requestParameters: ExpandBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExpandedBitlink> {
        const response = await this.expandBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns information for the specified link.
     * Retrieve a Bitlink
     */
    async getBitlinkRaw(requestParameters: GetBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BitlinkBody>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getBitlink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BitlinkBodyFromJSON(jsonValue));
    }

    /**
     * Returns information for the specified link.
     * Retrieve a Bitlink
     */
    async getBitlink(requestParameters: GetBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BitlinkBody> {
        const response = await this.getBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a paginated collection of Bitlinks for a group. The list of custom bitlinks has newest entries first.
     * Retrieve Bitlinks by Group
     */
    async getBitlinksByGroupRaw(requestParameters: GetBitlinksByGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Bitlinks>> {
        if (requestParameters['group_guid'] == null) {
            throw new runtime.RequiredError(
                'group_guid',
                'Required parameter "group_guid" was null or undefined when calling getBitlinksByGroup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['search_after'] != null) {
            queryParameters['search_after'] = requestParameters['search_after'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['hostname_path_query'] != null) {
            queryParameters['hostname_path_query'] = requestParameters['hostname_path_query'];
        }

        if (requestParameters['created_before'] != null) {
            queryParameters['created_before'] = requestParameters['created_before'];
        }

        if (requestParameters['created_after'] != null) {
            queryParameters['created_after'] = requestParameters['created_after'];
        }

        if (requestParameters['archived'] != null) {
            queryParameters['archived'] = requestParameters['archived'];
        }

        if (requestParameters['deeplinks'] != null) {
            queryParameters['deeplinks'] = requestParameters['deeplinks'];
        }

        if (requestParameters['domain_deeplinks'] != null) {
            queryParameters['domain_deeplinks'] = requestParameters['domain_deeplinks'];
        }

        if (requestParameters['campaign_guid'] != null) {
            queryParameters['campaign_guid'] = requestParameters['campaign_guid'];
        }

        if (requestParameters['channel_guid'] != null) {
            queryParameters['channel_guid'] = requestParameters['channel_guid'];
        }

        if (requestParameters['custom_bitlink'] != null) {
            queryParameters['custom_bitlink'] = requestParameters['custom_bitlink'];
        }

        if (requestParameters['has_qr_codes'] != null) {
            queryParameters['has_qr_codes'] = requestParameters['has_qr_codes'];
        }

        if (requestParameters['tags'] != null) {
            queryParameters['tags'] = requestParameters['tags'];
        }

        if (requestParameters['launchpad_ids'] != null) {
            queryParameters['launchpad_ids'] = requestParameters['launchpad_ids'];
        }

        if (requestParameters['encoding_login'] != null) {
            queryParameters['encoding_login'] = requestParameters['encoding_login'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/groups/{group_guid}/bitlinks`;
        urlPath = urlPath.replace(`{${"group_guid"}}`, encodeURIComponent(String(requestParameters['group_guid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BitlinksFromJSON(jsonValue));
    }

    /**
     * Returns a paginated collection of Bitlinks for a group. The list of custom bitlinks has newest entries first.
     * Retrieve Bitlinks by Group
     */
    async getBitlinksByGroup(requestParameters: GetBitlinksByGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Bitlinks> {
        const response = await this.getBitlinksByGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the click counts for the specified link in an array based on a date.
     * Get Clicks for a Bitlink
     */
    async getClicksForBitlinkRaw(requestParameters: GetClicksForBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Clicks>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getClicksForBitlink().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getClicksForBitlink().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getClicksForBitlink().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}/clicks`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClicksFromJSON(jsonValue));
    }

    /**
     * Returns the click counts for the specified link in an array based on a date.
     * Get Clicks for a Bitlink
     */
    async getClicksForBitlink(requestParameters: GetClicksForBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Clicks> {
        const response = await this.getClicksForBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the click counts for the specified link rolled up into a single field.
     * Get a Clicks Summary for a Bitlink
     */
    async getClicksSummaryForBitlinkRaw(requestParameters: GetClicksSummaryForBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClicksSummary>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getClicksSummaryForBitlink().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getClicksSummaryForBitlink().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getClicksSummaryForBitlink().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}/clicks/summary`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClicksSummaryFromJSON(jsonValue));
    }

    /**
     * Returns the click counts for the specified link rolled up into a single field.
     * Get a Clicks Summary for a Bitlink
     */
    async getClicksSummaryForBitlink(requestParameters: GetClicksSummaryForBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClicksSummary> {
        const response = await this.getClicksSummaryForBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the city origins of click traffic for the specified link.
     * Get Metrics for a Bitlink by City
     */
    async getMetricsForBitlinkByCitiesRaw(requestParameters: GetMetricsForBitlinkByCitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CityMetrics>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getMetricsForBitlinkByCities().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getMetricsForBitlinkByCities().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getMetricsForBitlinkByCities().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}/cities`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CityMetricsFromJSON(jsonValue));
    }

    /**
     * Returns the city origins of click traffic for the specified link.
     * Get Metrics for a Bitlink by City
     */
    async getMetricsForBitlinkByCities(requestParameters: GetMetricsForBitlinkByCitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CityMetrics> {
        const response = await this.getMetricsForBitlinkByCitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the country origins of click traffic for the specified link.
     * Get Metrics for a Bitlink by Country
     */
    async getMetricsForBitlinkByCountriesRaw(requestParameters: GetMetricsForBitlinkByCountriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClickMetrics>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getMetricsForBitlinkByCountries().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getMetricsForBitlinkByCountries().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getMetricsForBitlinkByCountries().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}/countries`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClickMetricsFromJSON(jsonValue));
    }

    /**
     * Returns the country origins of click traffic for the specified link.
     * Get Metrics for a Bitlink by Country
     */
    async getMetricsForBitlinkByCountries(requestParameters: GetMetricsForBitlinkByCountriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClickMetrics> {
        const response = await this.getMetricsForBitlinkByCountriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the device types generating click traffic to the specified link.
     * Get Metrics for a Bitlink by Device Type
     */
    async getMetricsForBitlinkByDevicesRaw(requestParameters: GetMetricsForBitlinkByDevicesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeviceMetrics>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getMetricsForBitlinkByDevices().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getMetricsForBitlinkByDevices().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getMetricsForBitlinkByDevices().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}/devices`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeviceMetricsFromJSON(jsonValue));
    }

    /**
     * Returns the device types generating click traffic to the specified link.
     * Get Metrics for a Bitlink by Device Type
     */
    async getMetricsForBitlinkByDevices(requestParameters: GetMetricsForBitlinkByDevicesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeviceMetrics> {
        const response = await this.getMetricsForBitlinkByDevicesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns referrer click counts for the specified link.
     * Get Metrics for a Bitlink by Referrer Name
     */
    async getMetricsForBitlinkByReferrerNameRaw(requestParameters: GetMetricsForBitlinkByReferrerNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClickMetrics>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getMetricsForBitlinkByReferrerName().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getMetricsForBitlinkByReferrerName().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getMetricsForBitlinkByReferrerName().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}/referrer_name`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClickMetricsFromJSON(jsonValue));
    }

    /**
     * Returns referrer click counts for the specified link.
     * Get Metrics for a Bitlink by Referrer Name
     */
    async getMetricsForBitlinkByReferrerName(requestParameters: GetMetricsForBitlinkByReferrerNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClickMetrics> {
        const response = await this.getMetricsForBitlinkByReferrerNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns referrer click counts for the specified link.
     * Get Metrics for a Bitlink by Referrers
     */
    async getMetricsForBitlinkByReferrersRaw(requestParameters: GetMetricsForBitlinkByReferrersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClickMetrics>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getMetricsForBitlinkByReferrers().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getMetricsForBitlinkByReferrers().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getMetricsForBitlinkByReferrers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}/referrers`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClickMetricsFromJSON(jsonValue));
    }

    /**
     * Returns referrer click counts for the specified link.
     * Get Metrics for a Bitlink by Referrers
     */
    async getMetricsForBitlinkByReferrers(requestParameters: GetMetricsForBitlinkByReferrersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClickMetrics> {
        const response = await this.getMetricsForBitlinkByReferrersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns click metrics grouped by referrers for the specified link.
     * Get Metrics for a Bitlink by Referrers by Domain
     */
    async getMetricsForBitlinkByReferrersByDomainsRaw(requestParameters: GetMetricsForBitlinkByReferrersByDomainsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReferrersByDomains>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getMetricsForBitlinkByReferrersByDomains().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getMetricsForBitlinkByReferrersByDomains().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getMetricsForBitlinkByReferrersByDomains().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}/referrers_by_domains`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReferrersByDomainsFromJSON(jsonValue));
    }

    /**
     * Returns click metrics grouped by referrers for the specified link.
     * Get Metrics for a Bitlink by Referrers by Domain
     */
    async getMetricsForBitlinkByReferrersByDomains(requestParameters: GetMetricsForBitlinkByReferrersByDomainsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReferrersByDomains> {
        const response = await this.getMetricsForBitlinkByReferrersByDomainsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the referring domain click counts for the specified link.
     * Get Metrics for a Bitlink by Referring Domains
     */
    async getMetricsForBitlinkByReferringDomainsRaw(requestParameters: GetMetricsForBitlinkByReferringDomainsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClickMetrics>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling getMetricsForBitlinkByReferringDomains().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling getMetricsForBitlinkByReferringDomains().'
            );
        }

        if (requestParameters['units'] == null) {
            throw new runtime.RequiredError(
                'units',
                'Required parameter "units" was null or undefined when calling getMetricsForBitlinkByReferringDomains().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}/referring_domains`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClickMetricsFromJSON(jsonValue));
    }

    /**
     * Returns the referring domain click counts for the specified link.
     * Get Metrics for a Bitlink by Referring Domains
     */
    async getMetricsForBitlinkByReferringDomains(requestParameters: GetMetricsForBitlinkByReferringDomainsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClickMetrics> {
        const response = await this.getMetricsForBitlinkByReferringDomainsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Bitlinks sorted by group. The list of custom bitlinks has newest entries first.
     * Retrieve Sorted Bitlinks for Group
     */
    async getSortedBitlinksRaw(requestParameters: GetSortedBitlinksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SortedLinks>> {
        if (requestParameters['group_guid'] == null) {
            throw new runtime.RequiredError(
                'group_guid',
                'Required parameter "group_guid" was null or undefined when calling getSortedBitlinks().'
            );
        }

        if (requestParameters['sort'] == null) {
            throw new runtime.RequiredError(
                'sort',
                'Required parameter "sort" was null or undefined when calling getSortedBitlinks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['unit_reference'] != null) {
            queryParameters['unit_reference'] = requestParameters['unit_reference'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/groups/{group_guid}/bitlinks/{sort}`;
        urlPath = urlPath.replace(`{${"group_guid"}}`, encodeURIComponent(String(requestParameters['group_guid'])));
        urlPath = urlPath.replace(`{${"sort"}}`, encodeURIComponent(String(requestParameters['sort'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SortedLinksFromJSON(jsonValue));
    }

    /**
     * Returns a list of Bitlinks sorted by group. The list of custom bitlinks has newest entries first.
     * Retrieve Sorted Bitlinks for Group
     */
    async getSortedBitlinks(requestParameters: GetSortedBitlinksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SortedLinks> {
        const response = await this.getSortedBitlinksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates fields in the specified link. To redirect the link (i.e. to update the Long URL), use the long_url parameter. This will always charge an encode limit.
     * Update a Bitlink
     */
    async updateBitlinkRaw(requestParameters: UpdateBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BitlinkBody>> {
        if (requestParameters['bitlink'] == null) {
            throw new runtime.RequiredError(
                'bitlink',
                'Required parameter "bitlink" was null or undefined when calling updateBitlink().'
            );
        }

        if (requestParameters['bitlink_update_body'] == null) {
            throw new runtime.RequiredError(
                'bitlink_update_body',
                'Required parameter "bitlink_update_body" was null or undefined when calling updateBitlink().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/bitlinks/{bitlink}`;
        urlPath = urlPath.replace(`{${"bitlink"}}`, encodeURIComponent(String(requestParameters['bitlink'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: BitlinkUpdateBodyToJSON(requestParameters['bitlink_update_body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BitlinkBodyFromJSON(jsonValue));
    }

    /**
     * Updates fields in the specified link. To redirect the link (i.e. to update the Long URL), use the long_url parameter. This will always charge an encode limit.
     * Update a Bitlink
     */
    async updateBitlink(requestParameters: UpdateBitlinkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BitlinkBody> {
        const response = await this.updateBitlinkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk update can add or remove tags or archive up to 100 links at a time; The response includes a list of bitlink ids that were updated.
     * Bulk update bitlinks
     */
    async updateBitlinksByGroupRaw(requestParameters: UpdateBitlinksByGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BulkUpdate>> {
        if (requestParameters['group_guid'] == null) {
            throw new runtime.RequiredError(
                'group_guid',
                'Required parameter "group_guid" was null or undefined when calling updateBitlinksByGroup().'
            );
        }

        if (requestParameters['bulk_update_request'] == null) {
            throw new runtime.RequiredError(
                'bulk_update_request',
                'Required parameter "bulk_update_request" was null or undefined when calling updateBitlinksByGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/groups/{group_guid}/bitlinks`;
        urlPath = urlPath.replace(`{${"group_guid"}}`, encodeURIComponent(String(requestParameters['group_guid'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: BulkUpdateRequestToJSON(requestParameters['bulk_update_request']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BulkUpdateFromJSON(jsonValue));
    }

    /**
     * Bulk update can add or remove tags or archive up to 100 links at a time; The response includes a list of bitlink ids that were updated.
     * Bulk update bitlinks
     */
    async updateBitlinksByGroup(requestParameters: UpdateBitlinksByGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BulkUpdate> {
        const response = await this.updateBitlinksByGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
  * @export
  * @enum {string}
  */
export enum GetBitlinksByGroupArchivedEnum {
    on = 'on',
    off = 'off',
    both = 'both'
}
/**
  * @export
  * @enum {string}
  */
export enum GetBitlinksByGroupDeeplinksEnum {
    on = 'on',
    off = 'off',
    both = 'both'
}
/**
  * @export
  * @enum {string}
  */
export enum GetBitlinksByGroupDomainDeeplinksEnum {
    on = 'on',
    off = 'off',
    both = 'both'
}
/**
  * @export
  * @enum {string}
  */
export enum GetBitlinksByGroupCustomBitlinkEnum {
    on = 'on',
    off = 'off',
    both = 'both'
}
/**
  * @export
  * @enum {string}
  */
export enum GetBitlinksByGroupHasQrCodesEnum {
    on = 'on',
    off = 'off',
    both = 'both'
}
/**
  * @export
  * @enum {string}
  */
export enum GetSortedBitlinksSortEnum {
    clicks = 'clicks'
}
